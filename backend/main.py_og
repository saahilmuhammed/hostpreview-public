from fastapi import FastAPI, HTTPException, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, validator
import uuid
import httpx
import ssl
import re
import gzip
import zlib
from typing import Optional

app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PreviewRequest(BaseModel):
    domain: str
    ip: str

    @validator('domain')
    def validate_domain(cls, v):
        domain_pattern = r'^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
        if not re.match(domain_pattern, v, re.IGNORECASE):
            raise ValueError('Invalid domain format')
        return v.lower()

    @validator('ip')
    def validate_ip(cls, v):
        ip_pattern = r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
        if not re.match(ip_pattern, v):
            raise ValueError('Invalid IP address format')
        return v

preview_links = {}

@app.post("/api/preview-link")
async def generate_preview_link(req: PreviewRequest):
    """Generate a preview link for the given domain and IP"""
    if not req.domain or not req.ip:
        raise HTTPException(status_code=400, detail="Domain and IP required")
    
    preview_id = str(uuid.uuid4())[:8]
    preview_links[preview_id] = {"domain": req.domain, "ip": req.ip}
    return {"previewUrl": f"/preview/{preview_id}/"}

@app.get("/api/preview/{preview_id}/status")
async def check_preview_status(preview_id: str):
    """Check if a preview link exists"""
    data = preview_links.get(preview_id)
    if not data:
        raise HTTPException(status_code=404, detail="Preview link not found")
    return {"exists": True, "domain": data["domain"], "ip": data["ip"]}

@app.api_route("/preview/{preview_id}/{full_path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"])
async def preview_proxy(preview_id: str, full_path: str = "", request: Request = None):
    """Proxy requests to the target IP with the specified domain as Host header"""
    data = preview_links.get(preview_id)
    if not data:
        raise HTTPException(status_code=404, detail="Preview link not found")
    
    domain = data["domain"]
    ip = data["ip"]
    
    # Build query string
    query_string = str(request.query_params) if request.query_params else ""
    if query_string:
        full_path = f"{full_path}?{query_string}" if full_path else f"?{query_string}"
    
    # Try HTTPS first, then HTTP
    for scheme in ["https", "http"]:
        target_url = f"{scheme}://{ip}/{full_path}"
        
        # Prepare headers
        headers = {}
        for key, value in request.headers.items():
            # Skip hop-by-hop headers and encoding headers (we'll handle compression ourselves)
            if key.lower() not in [
                "connection", "keep-alive", "proxy-authenticate",
                "proxy-authorization", "te", "trailers", "upgrade",
                "transfer-encoding", "host", "accept-encoding"
            ]:
                headers[key] = value
        
        # Set the Host header to the domain
        headers["host"] = domain
        
        # Don't request compression - get uncompressed content to avoid issues
        # This ensures we get plain text/HTML without compression problems
        headers["accept-encoding"] = "identity"
        
        try:
            # Prepare request body
            body = None
            if request.method in ("POST", "PUT", "PATCH"):
                body = await request.body()
            
            # Create SSL context for HTTPS
            ssl_ctx = None
            if scheme == "https":
                ssl_ctx = ssl.create_default_context()
                ssl_ctx.check_hostname = False
                ssl_ctx.verify_mode = ssl.CERT_NONE
            
            # Make the request - get uncompressed content
            timeout = httpx.Timeout(15.0, connect=10.0)
            async with httpx.AsyncClient(
                verify=ssl_ctx, 
                timeout=timeout, 
                follow_redirects=True,
            ) as client:
                resp = await client.request(
                    request.method,
                    target_url,
                    headers=headers,
                    content=body,
                )
                
                # Read response content
                # Since we requested identity encoding, content should be uncompressed
                # But handle compression if server sends it anyway
                raw_content = await resp.aread()
                content_encoding = resp.headers.get("content-encoding", "").lower().strip()
                
                # Decompress only if server sent compressed content despite our request
                if content_encoding and content_encoding != "identity":
                    try:
                        if "gzip" in content_encoding or "x-gzip" in content_encoding:
                            content = gzip.decompress(raw_content)
                        elif "deflate" in content_encoding:
                            try:
                                content = zlib.decompress(raw_content)
                            except zlib.error:
                                content = zlib.decompress(raw_content, -zlib.MAX_WBITS)
                        elif "br" in content_encoding:
                            try:
                                import brotli
                                content = brotli.decompress(raw_content)
                            except (ImportError, Exception):
                                content = raw_content
                        else:
                            content = raw_content
                    except Exception:
                        content = raw_content
                else:
                    # No compression or identity encoding
                    content = raw_content
                
                # Get status code and headers
                status_code = resp.status_code
                response_headers_dict = dict(resp.headers)
            
            # Filter response headers
            excluded_headers = [
                "connection", "keep-alive", "proxy-authenticate",
                "proxy-authorization", "te", "trailers", "upgrade",
                "transfer-encoding", "content-encoding", "content-length",
                "x-frame-options", "frame-ancestors",
                "content-security-policy", "content-security-policy-report-only"
            ]
            
            response_headers = {}
            for key, value in response_headers_dict.items():
                key_lower = key.lower()
                if key_lower not in excluded_headers:
                    response_headers[key] = value
            
            # Remove content-encoding header since we've decompressed
            if "content-encoding" in response_headers:
                del response_headers["content-encoding"]
            
            # Set correct content-length for decompressed content
            response_headers["content-length"] = str(len(content))
            
            # Handle content type
            content_type = response_headers_dict.get("content-type")

            # Rewrite relative asset URLs in HTML so they route through the preview path
            if content_type and "text/html" in content_type.lower():
                try:
                    charset = resp.encoding if getattr(resp, "encoding", None) else "utf-8"
                    html_text = content.decode(charset, errors="ignore")
                    preview_prefix = f"/preview/{preview_id}/"

                    # Rewrite href/src/action/content/data/poster attributes that start with "/"
                    attr_pattern = re.compile(
                        r'(\b(?:href|src|action|data|poster|content)=["\'])/(?!preview/)',
                        flags=re.IGNORECASE
                    )
                    html_text = attr_pattern.sub(rf'\1{preview_prefix}', html_text)

                    # Rewrite CSS url(/...) references
                    html_text = re.sub(
                        r'url\(/(?!preview/)',
                        f'url({preview_prefix}',
                        html_text,
                        flags=re.IGNORECASE
                    )

                    content = html_text.encode(charset)
                    response_headers["content-length"] = str(len(content))
                except Exception:
                    # If rewriting fails, fall back to original content
                    pass
            
            return Response(
                content=content,
                status_code=status_code,
                headers=response_headers,
                media_type=content_type
            )
            
        except httpx.TimeoutException:
            # Continue to try HTTP if HTTPS times out
            if scheme == "https":
                continue
            raise HTTPException(
                status_code=504,
                detail=f"Connection timeout. The server at {ip} is not responding. Please verify the IP address is correct."
            )
        except httpx.ConnectError:
            # Continue to try HTTP if HTTPS connection fails
            if scheme == "https":
                continue
            raise HTTPException(
                status_code=502,
                detail=f"Cannot connect to {ip}. Please verify the IP address is correct and the server is accessible."
            )
        except httpx.HTTPStatusError as e:
            # If we get an HTTP error, still return it (might be 404, 500, etc.)
            raise HTTPException(
                status_code=e.response.status_code,
                detail=f"Server returned error: {e.response.status_code}"
            )
        except Exception as e:
            # For other errors, try HTTP if we were on HTTPS
            if scheme == "https":
                continue
            raise HTTPException(
                status_code=502,
                detail=f"Error connecting to {ip}: {str(e)}"
            )
    
    # If we get here, both HTTPS and HTTP failed
    raise HTTPException(
        status_code=502,
        detail=f"Could not connect to {domain} at {ip}. Please verify the IP address is correct and the server is accessible."
    )

@app.get("/")
async def root():
    return {"message": "HostPreview API"}
